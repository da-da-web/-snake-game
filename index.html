<!doctype html>
<html lang="zh-cn">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>极简规则贪吃蛇</title>
<style>
  /* —— 极简样式 —— */
  html,body{height:100%;margin:0;background:#0f1220;color:#e8ecff;font:14px/1.4 system-ui,-apple-system,"PingFang SC",Arial}
  .wrap{max-width:760px;margin:0 auto;padding:16px;display:grid;grid-template-columns:1fr 220px;gap:12px}
  canvas{width:100%;height:auto;background:#171b2e;border-radius:10px}
  .side{background:#171b2e;border-radius:10px;padding:10px}
  .row{margin:6px 0}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#273055;color:#b7c0ea;font-size:12px}
  @media (max-width:860px){.wrap{grid-template-columns:1fr}}
</style>

<body>
<div class="wrap">
  <canvas id="c" width="600" height="600" aria-label="board"></canvas>

  <aside class="side">
    <div class="row"><b>极简规则贪吃蛇</b> <span class="badge">IF-THEN + 可达空间</span></div>
    <div class="row">分数：<span id="sc">0</span>　最高：<span id="hi">0</span>　AI：<span id="ai">OFF</span></div>
    <div class="row">操作：↑↓←→ / WASD · <b>A</b> 开关AI · <b>Space</b> 暂停/继续 · <b>R</b> 重开</div>
    <div class="row" id="log" style="min-height:44px;white-space:pre-line;color:#cbd5ff;background:#131935;border-radius:8px;padding:8px">规则日志…</div>
  </aside>
</div>

<script>
/* =========================
   极简规则贪吃蛇（单文件）
   - 固定棋盘 22x22，固定速度 12 格/秒
   - 核心：IF-THEN 规则 + 生存性评估（模拟一步 + 可达空间）
   ========================= */

(() => {
  // ---------- 基础状态 ----------
  const G = 22;                    // 网格边长
  const SPEED = 12;                // 固定速度（格/秒）
  const CELL_PX = 600 / G;         // 每格像素（画布 600x600）
  const DIRS = {Up:{x:0,y:-1},Down:{x:0,y:1},Left:{x:-1,y:0},Right:{x:1,y:0}};
  const c = document.getElementById('c'), ctx = c.getContext('2d');
  const scEl = document.getElementById('sc'), hiEl = document.getElementById('hi');
  const aiEl = document.getElementById('ai'), logEl = document.getElementById('log');

  const st = {
    snake: [], dir: DIRS.Right, nextDir: DIRS.Right,
    food: {x:5,y:5}, score:0, hi:+(localStorage.getItem('mini_hi')||0),
    running: true, ai:false, rule:''
  };

  // ---------- 小工具 ----------
  const same = (a,b)=>a.x===b.x && a.y===b.y;
  const add  = (a,b)=>({x:a.x+b.x, y:a.y+b.y});
  const neg  = a=>({x:-a.x,y:-a.y});
  const within = (x,y)=>x>=0&&y>=0&&x<G&&y<G;

  function occupied(x,y,arr){
    for(let i=0;i<arr.length;i++){ if(arr[i].x===x && arr[i].y===y) return true; }
    return false;
  }

  function placeFood(){
    while(true){
      const f = {x:Math.floor(Math.random()*G), y:Math.floor(Math.random()*G)};
      if(!occupied(f.x,f.y,st.snake)){ st.food=f; return; }
    }
  }

  // ---------- 绘制 ----------
  function drawGrid(){
    ctx.fillStyle = '#171b2e'; ctx.fillRect(0,0,c.width,c.height);
    ctx.strokeStyle = '#141829'; ctx.lineWidth = 1;
    for(let i=1;i<G;i++){
      const p=Math.floor(i*CELL_PX)+.5;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,c.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(c.width,p); ctx.stroke();
    }
  }
  function drawFood(){
    ctx.fillStyle = '#ef4444';
    const pad = CELL_PX*0.15, s=CELL_PX-pad*2;
    ctx.fillRect(st.food.x*CELL_PX+pad, st.food.y*CELL_PX+pad, s, s);
  }
  function drawSnake(){
    for(let i=0;i<st.snake.length;i++){
      const p=st.snake[i];
      const pad = i? CELL_PX*0.22 : CELL_PX*0.12, s=CELL_PX-pad*2;
      ctx.fillStyle = i? '#60a5fa' : '#93c5fd';
      ctx.fillRect(p.x*CELL_PX+pad, p.y*CELL_PX+pad, s, s);
    }
  }
  function render(){ drawGrid(); drawFood(); drawSnake(); drawHUD(); }
  function drawHUD(){
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,180,40);
    ctx.fillStyle='#cbd5ff'; ctx.font='bold 14px system-ui';
    ctx.fillText(`分数:${st.score}`,10,17); ctx.fillText(`最高:${st.hi}`,10,34);
    ctx.textAlign='right'; ctx.fillText(`AI:${st.ai?'ON':'OFF'}`,175,17);
    ctx.fillText(`${SPEED}格/秒`,175,34); ctx.textAlign='start';
  }

  // ---------- 可达空间评估（核心简化版） ----------
  function isSafe(dir){
    const head=st.snake[0], nx=head.x+dir.x, ny=head.y+dir.y;
    if(!within(nx,ny)) return false;
    const eat = (nx===st.food.x && ny===st.food.y);
    for(let i=0;i<st.snake.length;i++){
      const seg=st.snake[i], isTail=(i===st.snake.length-1);
      if(seg.x===nx && seg.y===ny){ if(isTail && !eat) continue; return false; }
    }
    return true;
  }

  function simulate(dir){
    const s = st.snake.map(p=>({x:p.x,y:p.y}));
    const newHead = {x:s[0].x+dir.x,y:s[0].y+dir.y};
    const ate = same(newHead,st.food);
    s.unshift(newHead); if(!ate) s.pop();
    // 临时食物（仅用于区域估计）
    let nf = st.food;
    if(ate){
      const used = new Set(s.map(p=>p.x+','+p.y));
      outer: for(let y=0;y<G;y++) for(let x=0;x<G;x++){
        if(!used.has(x+','+y)){ nf={x,y}; break outer; }
      }
    }
    return {snake:s, food:nf};
  }

  function area(sim){
    const used = new Set(sim.snake.map(p=>p.x+','+p.y));
    const head = sim.snake[0], tailKey = sim.snake[sim.snake.length-1].x+','+sim.snake[sim.snake.length-1].y;
    const q=[head], seen=new Set([head.x+','+head.y]); let cnt=0;
    while(q.length){
      const p=q.shift(); cnt++;
      const nbrs=[{x:p.x+1,y:p.y},{x:p.x-1,y:p.y},{x:p.x,y:p.y+1},{x:p.x,y:p.y-1}];
      for(const n of nbrs){
        if(!within(n.x,n.y)) continue;
        const k=n.x+','+n.y;
        if(seen.has(k)) continue;
        if(used.has(k) && k!==tailKey) continue; // 允许踩旧尾
        seen.add(k); q.push(n);
      }
    }
    return cnt;
  }

  function survivable(dir){
    if(!isSafe(dir)) return false;
    const sim = simulate(dir);
    const okArea = Math.min(sim.snake.length, 12);
    if(area(sim) < okArea) return false;

    // 模拟后至少还有一步可走
    const head=sim.snake[0];
    const tryDirs=[DIRS.Up,DIRS.Down,DIRS.Left,DIRS.Right];
    for(const d of tryDirs){
      const nx=head.x+d.x, ny=head.y+d.y;
      if(!within(nx,ny)) continue;
      const eat=(nx===sim.food.x && ny===sim.food.y); let bad=false;
      for(let i=0;i<sim.snake.length;i++){
        const seg=sim.snake[i], isTail=(i===sim.snake.length-1);
        if(seg.x===nx && seg.y===ny){ if(isTail && !eat) continue; bad=true; break; }
      }
      if(!bad) return true;
    }
    return false;
  }

  function bestBySpace(cands){
    let best=null, score=-1;
    for(const d of cands){
      if(!isSafe(d)) continue;
      const s=area(simulate(d));
      if(s>score){score=s;best=d;}
    }
    if(best){ st.rule='兜底：可达空间最大'; }
    return best;
  }

  function chooseDir(){
    const head=st.snake[0], food=st.food, cur=st.dir;
    const dx=Math.sign(food.x-head.x), dy=Math.sign(food.y-head.y);
    const towardX = dx===1?DIRS.Right:dx===-1?DIRS.Left:null;
    const towardY = dy===1?DIRS.Down:dy===-1?DIRS.Up:null;
    const distX=Math.abs(food.x-head.x), distY=Math.abs(food.y-head.y);
    let pri = distX>=distY ? [towardX,towardY,cur,left(cur),right(cur)]
                           : [towardY,towardX,cur,left(cur),right(cur)];
    pri = pri.filter(Boolean);

    for(const d of pri){
      if(same(d,neg(cur))) continue;
      if(survivable(d)){
        st.rule = (d===towardX||d===towardY)?'朝食物且不致困':'直行/转向可生存';
        return d;
      }
    }
    const best = bestBySpace([DIRS.Up,DIRS.Down,DIRS.Left,DIRS.Right].filter(d=>!same(d,neg(cur))));
    return best ?? neg(cur);
  }
  function left(d){ return d.x===1?DIRS.Up : d.x===-1?DIRS.Down : d.y===1?DIRS.Right:DIRS.Left; }
  function right(d){return d.x===1?DIRS.Down: d.x===-1?DIRS.Up   : d.y===1?DIRS.Left :DIRS.Right;}

  // ---------- 逻辑循环 ----------
  let last=0, acc=0;
  function step(){
    if(st.ai){ st.nextDir = chooseDir(); logEl.textContent = '【规则】'+st.rule; }
    if(!(st.snake.length>1 && same(st.nextDir,neg(st.dir)))) st.dir = st.nextDir;

    const nh = add(st.snake[0], st.dir);
    if(!within(nh.x,nh.y)) return gameOver();

    for(let i=0;i<st.snake.length;i++){
      const seg=st.snake[i], isTail=(i===st.snake.length-1);
      if(seg.x===nh.x && seg.y===nh.y){
        const eat=same(nh,st.food);
        if(!(isTail && !eat)) return gameOver();
      }
    }

    st.snake.unshift(nh);
    if(same(nh,st.food)){
      st.score++; scEl.textContent=st.score;
      if(st.score>st.hi){st.hi=st.score;hiEl.textContent=st.hi;localStorage.setItem('mini_hi',st.hi);}
      placeFood();
    }else{
      st.snake.pop();
    }
  }

  function loop(t){
    if(!st.running){ last=t; render(); return requestAnimationFrame(loop); }
    const dt=(t-last)/1000; last=t; acc+=dt;
    const itv = 1 / SPEED;
    while(acc>=itv){ step(); acc-=itv; }
    render(); requestAnimationFrame(loop);
  }

  // ---------- 生命周期 & 输入 ----------
  function reset(){
    const m = Math.floor(G/2);
    st.snake=[{x:m-1,y:m},{x:m-2,y:m}];
    st.dir=st.nextDir=DIRS.Right;
    st.food={x:m+3,y:m}; st.score=0; scEl.textContent='0';
    hiEl.textContent=st.hi; st.rule='等待中…'; logEl.textContent='规则日志…';
    placeFood(); st.running=true; aiEl.textContent=st.ai?'ON':'OFF';
  }

  window.addEventListener('keydown',e=>{
    const k=e.code||e.key;
    const map={ArrowUp:DIRS.Up,KeyW:DIRS.Up,ArrowDown:DIRS.Down,KeyS:DIRS.Down,
               ArrowLeft:DIRS.Left,KeyA:DIRS.Left,ArrowRight:DIRS.Right,KeyD:DIRS.Right};
    if(map[k]){
      const d=map[k]; if(!(st.snake.length>1 && same(d,neg(st.dir)))) st.nextDir=d; e.preventDefault();
    }else if(k==='Space' || k==='Enter'){ st.running=!st.running; e.preventDefault();
    }else if(k==='KeyA' && e.key==='a'){ /* 防止和左键A混淆，此处不用 */ 
    }else if(e.key==='a' || e.key==='A'){ st.ai=!st.ai; aiEl.textContent=st.ai?'ON':'OFF'; e.preventDefault();
    }else if(e.key==='r' || e.key==='R'){ reset(); e.preventDefault();}
  },{passive:false});

  function gameOver(){
    st.running=false; render();
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle='#fee2e2'; ctx.font='bold 28px system-ui'; ctx.textAlign='center';
    ctx.fillText('游戏结束', c.width/2, c.height/2-6);
    ctx.font='14px system-ui'; ctx.fillStyle='#cbd5ff';
    ctx.fillText('R 重开 · Space 继续', c.width/2, c.height/2+20);
  }

  // 启动
  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
