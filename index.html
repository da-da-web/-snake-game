<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>规则贪吃蛇 · Rule-based Snake</title>
<style>
  :root{
    --bg:#0f1220;
    --panel:#171b2e;
    --text:#e8ecff;
    --muted:#9aa3c8;
    --green:#22c55e;
    --red:#ef4444;
    --yellow:#f59e0b;
    --grid:#141829;
    --snake:#60a5fa;
    --snakeHead:#93c5fd;
    --food:#f87171;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 70% -10%, #1a2040 0%, var(--bg) 50%) fixed;
    color:var(--text); font:16px/1.5 system-ui, -apple-system, "PingFang SC", "Segoe UI", Roboto, "Helvetica Neue",
      "Noto Sans", "Microsoft Yahei", Arial, sans-serif;
    display:flex; align-items:center; justify-content:center; padding:18px;
  }
  .app{width:min(920px, 98vw)}
  h1{margin:0 0 .25rem; font-size:22px}
  .sub{color:var(--muted); margin-bottom:10px}
  .wrap{
    display:grid; grid-template-columns: 1fr 280px; gap:16px;
  }
  canvas{
    width:100%; height:auto; border-radius:16px; background:var(--panel);
    box-shadow:0 6px 36px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
  }
  .side{
    background:var(--panel); border-radius:16px; padding:14px 14px;
    box-shadow:0 6px 36px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
  }
  .row{display:flex; gap:8px; align-items:center; margin:8px 0}
  button, .btn{
    appearance:none; border:0; padding:9px 12px; border-radius:10px;
    background:#2a3155; color:var(--text); cursor:pointer; font-weight:600;
  }
  button:disabled{opacity:.55; cursor:not-allowed}
  .btn-primary{background:#35407a}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; background:#273055; color:#b7c0ea}
  .k{padding:.2em .5em; border-radius:6px; background:#222848; color:#cbd5ff; font-weight:600; margin:0 .15em}
  .log{
    margin-top:8px; padding:8px; border-radius:10px; min-height:58px; color:#c7d2fe;
    background:#131935; font-size:13px; white-space:pre-line;
  }
  .hint{color:#aab3da; font-size:13px}
  .gridRow{display:flex; align-items:center; justify-content:space-between; gap:10px}
  input[type="range"]{width:100%}
  .scoreBoard{display:flex; gap:10px; margin:6px 0 2px}
  .score{font-size:18px; font-weight:800}
  .hi{color:#9ecbff}
  .controls{display:flex; flex-wrap:wrap; gap:8px; margin:6px 0}
  .ok{color:var(--green)} .warn{color:var(--yellow)} .err{color:var(--red)}
  @media (max-width: 900px){
    .wrap{grid-template-columns:1fr; gap:12px}
  }
</style>
</head>
<body>
<div class="app">
  <h1>规则贪吃蛇 <span class="badge">Classic AI · IF-THEN 规则</span></h1>
  <div class="sub">方向键/WASD 操作。按 <span class="k">A</span> 开关<strong>规则驱动</strong>（自动寻食不撞墙），
    <span class="k">Space</span> 暂停/继续，<span class="k">R</span> 重新开始。</div>
  <div class="wrap">
    <canvas id="board" width="720" height="720" aria-label="game board"></canvas>

    <aside class="side">
      <div class="scoreBoard">
        <div class="score">分数：<span id="score">0</span></div>
        <div class="score hi">最高：<span id="hi">0</span></div>
        <div class="badge" id="ai-badge">AI: 关闭</div>
      </div>

      <div class="controls">
        <button id="start" class="btn-primary">开始 / 继续</button>
        <button id="pause">暂停</button>
        <button id="restart">重新开始</button>
        <button id="toggle-ai">切换 AI</button>
      </div>

      <div class="gridRow">
        <div>速度</div>
        <input id="speed" type="range" min="4" max="20" step="1" value="10"/>
        <div><span class="badge" id="speedVal">10</span> 格/秒</div>
      </div>

      <div class="gridRow" style="margin-top:8px">
        <div>棋盘</div>
        <select id="size">
          <option value="18">18 × 18（紧凑）</option>
          <option value="22" selected>22 × 22（默认）</option>
          <option value="26">26 × 26（宽松）</option>
        </select>
      </div>

      <h3 style="margin:12px 0 6px">规则（IF-THEN）</h3>
      <div class="hint">
        机器人每一帧按下面顺序执行规则，首先命中的规则就会生效（可在“AI: 开启”时观察）。
      </div>
      <ol class="hint" style="margin:.6em 0 .4em .9em">
        <li>如果朝向食物的方向安全 <b>且不会把自己困住</b> → 朝食物移动（★ MOD）</li>
        <li>否则如果直行安全 <b>且下一步仍有路</b> → 直行（★ MOD）</li>
        <li>否则如果左转安全 <b>且空间更大</b> → 左转（★ MOD）</li>
        <li>否则如果右转安全 <b>且空间更大</b> → 右转（★ MOD）</li>
        <li>否则 → 选择可达空间最大的方向；再不行才掉头（★ MOD）</li>
      </ol>

      <div class="log" id="log">【规则日志】这里会实时显示“哪条规则触发了”。</div>
      <div class="hint">操作：↑↓←→ / WASD · A 开关 AI · Space 暂停/继续 · R 重开</div>
    </aside>
  </div>
</div>

<script>
/* =========================
   规则贪吃蛇（单文件版）
   - 经典 AI：基于 IF-THEN 规则的自动寻路
   - ★ MOD: 引入“模拟一步 + 可达空间”评估，避免把自己逼死或咬尾
   - 无任何外部依赖，直接在浏览器打开即可
   ========================= */

(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const aiBadge = document.getElementById('ai-badge');
  const speedSlider = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const sizeSel = document.getElementById('size');
  const logEl = document.getElementById('log');

  document.getElementById('start').onclick = () => resume();
  document.getElementById('pause').onclick = () => pause();
  document.getElementById('restart').onclick = () => restart();
  document.getElementById('toggle-ai').onclick = () => toggleAI();

  speedSlider.oninput = () => {
    speedVal.textContent = speedSlider.value;
    game.state.stepPerSec = +speedSlider.value;
  };
  sizeSel.onchange = () => restart(+sizeSel.value);

  const game = {
    grid: 22,
    cell: 30,
    state: {
      snake: [],
      dir: {x:1,y:0},
      nextDir: {x:1,y:0},
      food: {x:5,y:5},
      score: 0,
      hi: +(localStorage.getItem('rulesnake_hi')||0),
      stepPerSec: +speedSlider.value,
      running: false,
      ai: false,
      ruleFired: ''
    },
    time:{ acc:0, last:0 }
  };

  function fitCanvas(){
    const side = Math.min(720, Math.floor(Math.min(window.innerWidth*0.98, 900-280-20)));
    canvas.width = canvas.height = side>400? side : 560;
    game.cell = Math.floor(canvas.width / game.grid);
  }
  window.addEventListener('resize', fitCanvas);

  const DIRS = {
    Up:{x:0,y:-1}, Down:{x:0,y:1}, Left:{x:-1,y:0}, Right:{x:1,y:0}
  };
  function same(a,b){ return a.x===b.x && a.y===b.y; }
  function add(a,b){ return {x:a.x+b.x, y:a.y+b.y}; }
  function negate(a){ return {x:-a.x, y:-a.y}; }
  function turnLeft(d){ if(d.x===1) return DIRS.Up; if(d.x===-1) return DIRS.Down; if(d.y===1) return DIRS.Right; return DIRS.Left; }
  function turnRight(d){ if(d.x===1) return DIRS.Down; if(d.x===-1) return DIRS.Up; if(d.y===1) return DIRS.Left; return DIRS.Right; }
  function within(x,y){ return x>=0 && y>=0 && x<game.grid && y<game.grid; }

  function cellOccupied(x,y, snakeArr){
    for(let i=0;i<snakeArr.length;i++){
      const s = snakeArr[i];
      if(s.x===x && s.y===y) return true;
    }
    return false;
  }

  function rndInt(n){ return Math.floor(Math.random()*n); }
  function placeFood(){
    const s = game.state.snake;
    while(true){
      const f = {x:rndInt(game.grid), y:rndInt(game.grid)};
      if(!cellOccupied(f.x,f.y,s)){ game.state.food = f; break; }
    }
  }

  function updateBadge(){
    aiBadge.textContent = 'AI: ' + (game.state.ai ? '开启' : '关闭');
    aiBadge.style.background = game.state.ai ? '#1e2a5b' : '#273055';
    aiBadge.style.color = game.state.ai ? '#a7f3d0' : '#b7c0ea';
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawGrid(){
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel');
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const gcol = getComputedStyle(document.documentElement).getPropertyValue('--grid') || '#141829';
    ctx.strokeStyle = gcol;
    ctx.lineWidth = 1;
    for(let i=1;i<game.grid;i++){
      const p = Math.floor(i*game.cell)+.5;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(canvas.width,p); ctx.stroke();
    }
  }

  function drawFood(){
    const {x,y} = game.state.food;
    const pad = Math.floor(game.cell*0.12);
    const size = game.cell - pad*2;
    const gx = x*game.cell + pad, gy = y*game.cell + pad;
    const grad = ctx.createLinearGradient(gx,gy,gx+size,gy+size);
    grad.addColorStop(0, '#fca5a5'); grad.addColorStop(1, '#ef4444');
    ctx.fillStyle = grad;
    roundRect(gx, gy, size, size, Math.floor(size*0.25));
    ctx.fill();
  }

  function drawSnake(){
    const s = game.state.snake;
    for(let i=0;i<s.length;i++){
      const seg = s[i];
      const pad = i===0 ? Math.floor(game.cell*0.08) : Math.floor(game.cell*0.16);
      const size = game.cell - pad*2;
      const gx = seg.x*game.cell + pad, gy = seg.y*game.cell + pad;
      const grad = ctx.createLinearGradient(gx,gy,gx+size,gy+size);
      if(i===0){ grad.addColorStop(0, '#dbeafe'); grad.addColorStop(1, '#93c5fd'); }
      else{ grad.addColorStop(0, '#93c5fd'); grad.addColorStop(1, '#60a5fa'); }
      ctx.fillStyle = grad;
      roundRect(gx, gy, size, size, Math.floor(size*0.25));
      ctx.fill();
    }
  }

  function drawHUD(){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0, 200, 44);
    ctx.fillStyle = '#cbd5ff';
    ctx.font = 'bold 16px ui-sans-serif,system-ui';
    ctx.fillText(`分数: ${game.state.score}`, 10, 18);
    ctx.fillText(`最高: ${game.state.hi}`, 10, 38);
    ctx.textAlign = 'right';
    ctx.fillText(`AI: ${game.state.ai ? 'ON' : 'OFF'}`, 195, 18);
    ctx.fillText(`${game.state.stepPerSec} 格/秒`, 195, 38);
    ctx.restore();
  }

  function render(){ drawGrid(); drawFood(); drawSnake(); drawHUD(); }

  /* -------------------------
     ★ MOD: 可达空间评估工具
     ------------------------- */

  // 在给定方向上一步是否安全（考虑“如果不吃到食物，尾巴会移动，可踩旧尾”）
  function isSafeDirection(dir){
    const s = game.state.snake;
    const head = s[0], food = game.state.food;
    const nx = head.x + dir.x, ny = head.y + dir.y;
    if(!within(nx,ny)) return false;
    const willEat = (nx===food.x && ny===food.y);
    for(let i=0;i<s.length;i++){
      const seg = s[i];
      const isTail = (i===s.length-1);
      if(seg.x===nx && seg.y===ny){
        if(isTail && !willEat) continue; // 踩旧尾允许
        return false;
      }
    }
    return true;
  }

  // 模拟走一步，返回“新蛇身数组 & 新食物 & 是否吃到”
  // 用于评估下一步形势
  function simulateStep(dir){
    const st = game.state;
    const s = st.snake.map(p=>({x:p.x,y:p.y}));
    const newHead = {x:s[0].x + dir.x, y:s[0].y + dir.y};
    const ate = (newHead.x===st.food.x && newHead.y===st.food.y);
    s.unshift(newHead);
    if(!ate){ s.pop(); }
    // 新食物：若吃了，临时随便放个不冲突位置（仅用于空间估计，不影响真实游戏）
    let nf = st.food;
    if(ate){
      const taken = new Set(s.map(p=>p.x+','+p.y));
      // 简单找空位（棋盘不大，线性找就行）
      for(let y=0;y<game.grid;y++){
        let found=false;
        for(let x=0;x<game.grid;x++){
          if(!taken.has(x+','+y)){ nf = {x,y}; found=true; break; }
        }
        if(found) break;
      }
    }
    return {snake:s, food:nf, ate};
  }

  // flood-fill 估计从新头开始可达的空格数量
  function reachableArea(sim){
    const G = game.grid;
    const taken = new Set(sim.snake.map(p=>p.x+','+p.y));
    const head = sim.snake[0];
    const q = [head];
    const seen = new Set([head.x+','+head.y]);
    let count = 0;

    while(q.length){
      const p = q.shift(); count++;
      const nbrs = [{x:p.x+1,y:p.y},{x:p.x-1,y:p.y},{x:p.x,y:p.y+1},{x:p.x,y:p.y-1}];
      for(const n of nbrs){
        if(n.x<0||n.y<0||n.x>=G||n.y>=G) continue;
        const key = n.x+','+n.y;
        if(seen.has(key)) continue;
        // 允许把“尾巴”那一格视为可用，因为下一帧会挪走（只在未吃到食物时）
        const isTailKey = sim.snake[sim.snake.length-1].x+','+sim.snake[sim.snake.length-1].y;
        if(taken.has(key) && key!==isTailKey) continue;
        seen.add(key); q.push(n);
      }
    }
    return count;
  }

  // 检查下一步是否“不会把自己困死”：
  // 1) 这一步安全；
  // 2) flood-fill 可达空间 >= min(蛇长, 某阈值)；且模拟后至少存在一个安全下一步
  function survivable(dir){
    if(!isSafeDirection(dir)) return false;
    const sim = simulateStep(dir);
    const area = reachableArea(sim);
    const minNeed = Math.min(sim.snake.length, 12); // 阈值可调
    if(area < minNeed) return false;

    // 再看模拟后下一步是否还有解
    const head = sim.snake[0];
    const dirs = [DIRS.Up,DIRS.Down,DIRS.Left,DIRS.Right];
    for(const d of dirs){
      const nx = head.x + d.x, ny = head.y + d.y;
      if(nx<0||ny<0||nx>=game.grid||ny>=game.grid) continue;
      const willEat = (nx===sim.food.x && ny===sim.food.y);
      let collide = false;
      for(let i=0;i<sim.snake.length;i++){
        const seg = sim.snake[i]; const isTail = (i===sim.snake.length-1);
        if(seg.x===nx && seg.y===ny){
          if(isTail && !willEat) continue;
          collide = true; break;
        }
      }
      if(!collide) return true;
    }
    return false;
  }

  // 在一组候选方向里找“可达空间最大”的那个（兜底策略）
  function bestBySpace(candidates){
    let best = null, bestScore = -1, reason = '';
    for(const d of candidates){
      if(!isSafeDirection(d)) continue;
      const sim = simulateStep(d);
      const area = reachableArea(sim);
      if(area > bestScore){ bestScore = area; best = d; }
    }
    if(best){
      logEl.textContent = `【规则日志】兜底：可达空间最大（≈${bestScore}）→ 选择该方向`;
      game.state.ruleFired = "规则5：可达空间最大";
    }
    return best;
  }

  /* -------------------------
     AI 选择方向
     ------------------------- */
  function aiChooseDirection(){
    const s = game.state.snake;
    const head = s[0];
    const cur = game.state.dir;
    const food = game.state.food;

    const dx = Math.sign(food.x - head.x);
    const dy = Math.sign(food.y - head.y);
    const towardX = dx===1 ? DIRS.Right : (dx===-1 ? DIRS.Left : null);
    const towardY = dy===1 ? DIRS.Down : (dy===-1 ? DIRS.Up : null);

    // 构造优先级列表（朝食物优先，按远轴优先）
    const distX = Math.abs(food.x - head.x);
    const distY = Math.abs(food.y - head.y);
    let pri = [];
    if(distX >= distY) pri = [towardX, towardY, cur, turnLeft(cur), turnRight(cur)];
    else               pri = [towardY, towardX, cur, turnLeft(cur), turnRight(cur)];
    pri = pri.filter(Boolean);

    // 逐个规则尝试：既要安全，也要“可生存”
    for(const d of pri){
      if(same(d, negate(cur))) continue;      // 禁止直接掉头
      if(!isSafeDirection(d)) continue;       // 当前这步安全
      if(survivable(d)){                      // ★ MOD: 生存性评估
        if(d===towardX || d===towardY){
          game.state.ruleFired = "规则1：朝食物安全且不致困 → 前进";
        }else if(d===cur){
          game.state.ruleFired = "规则2：直行安全且后续有路 → 直行";
        }else if(same(d, turnLeft(cur))){
          game.state.ruleFired = "规则3：左转更优（空间更大） → 左转";
        }else if(same(d, turnRight(cur))){
          game.state.ruleFired = "规则4：右转更优（空间更大） → 右转";
        }else{
          game.state.ruleFired = "规则X：候选方向可生存 → 采用";
        }
        return d;
      }
    }

    // 兜底：在所有非掉头的安全方向里选空间最大的
    const dirs = [DIRS.Up, DIRS.Down, DIRS.Left, DIRS.Right].filter(d=>!same(d, negate(cur)));
    const best = bestBySpace(dirs);
    if(best) return best;

    // 实在不行才掉头（基本等价宣告失败）
    game.state.ruleFired = "规则5：无路可走 → 被迫掉头";
    return negate(cur);
  }

  /* -------------------------
     正常步进与循环
     ------------------------- */
  function step(){
    const st = game.state;
    if(st.ai){
      st.nextDir = aiChooseDirection();
      logEl.textContent = "【规则日志】" + st.ruleFired;
    }
    if(!(st.snake.length>1 && same(st.nextDir, negate(st.dir)))){
      st.dir = st.nextDir;
    }

    const head = st.snake[0];
    const newHead = add(head, st.dir);

    if(!within(newHead.x, newHead.y)){ gameOver(); return; }
    for(let i=0;i<st.snake.length;i++){
      const seg = st.snake[i];
      const isTail = (i===st.snake.length-1);
      if(seg.x===newHead.x && seg.y===newHead.y){
        const willEat = same(newHead, st.food);
        if(!(isTail && !willEat)){ gameOver(); return; }
      }
    }

    st.snake.unshift(newHead);

    if(same(newHead, st.food)){
      st.score += 1;
      if(st.score>st.hi){ st.hi = st.score; localStorage.setItem('rulesnake_hi', st.hi); }
      scoreEl.textContent = st.score;
      hiEl.textContent = st.hi;
      placeFood();
    }else{
      st.snake.pop();
    }
  }

  function tick(t){
    if(!game.state.running){ game.time.last = t; render(); return requestAnimationFrame(tick); }
    const dt = (t - game.time.last)/1000; game.time.last = t;
    game.time.acc += dt;

    const interval = 1 / game.state.stepPerSec;
    while(game.time.acc >= interval){
      step();
      game.time.acc -= interval;
    }
    render();
    requestAnimationFrame(tick);
  }

  function startState(g=game.grid){
    game.grid = g;
    fitCanvas();

    const mid = Math.floor(game.grid/2);
    game.state.snake = [{x:mid-1,y:mid}, {x:mid-2,y:mid}];
    game.state.dir = {x:1,y:0};
    game.state.nextDir = {x:1,y:0};
    game.state.food = {x:mid+3,y:mid};
    game.state.score = 0;
    scoreEl.textContent = '0';
    hiEl.textContent = game.state.hi;
    game.state.ruleFired = '';
    logEl.textContent = "【规则日志】等待中…";
    placeFood();
    render();
  }

  function gameOver(){
    game.state.running = false;
    render();
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fee2e2';
    ctx.font = 'bold 32px ui-sans-serif,system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('游戏结束', canvas.width/2, canvas.height/2 - 10);
    ctx.font = '16px ui-sans-serif,system-ui';
    ctx.fillStyle = '#cbd5ff';
    ctx.fillText('按 R 重新开始 · 按 Enter/空格 继续', canvas.width/2, canvas.height/2 + 22);
    ctx.restore();
  }

  function pause(){ game.state.running = false; }
  function resume(){ game.state.running = true; }
  function restart(g){ startState(g ?? game.grid); resume(); }
  function toggleAI(){ game.state.ai = !game.state.ai; updateBadge(); }

  const keyDir = {
    ArrowUp: DIRS.Up,    KeyW: DIRS.Up,
    ArrowDown: DIRS.Down,KeyS: DIRS.Down,
    ArrowLeft: DIRS.Left,KeyA: DIRS.Left,
    ArrowRight: DIRS.Right,KeyD: DIRS.Right
  };
  window.addEventListener('keydown', e=>{
    if(keyDir[e.code] || keyDir[e.key]){
      const d = keyDir[e.code] || keyDir[e.key];
      if(!(game.state.snake.length>1 && same(d, negate(game.state.dir)))){
        game.state.nextDir = d;
      }
      e.preventDefault();
    }else if(e.code==='Space' || e.code==='Enter'){
      game.state.running ? pause() : resume(); e.preventDefault();
    }else if(e.key==='a' || e.key==='A'){
      toggleAI(); e.preventDefault();
    }else if(e.key==='r' || e.key==='R'){
      restart(); e.preventDefault();
    }
  }, {passive:false});

  startState(+sizeSel.value);
  updateBadge();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
